---
title: CAN总线的数据解析
---

# CAN报文的种类和帧格式解析
<!-- more -->
## 1.1 报文种类
数据帧：用于发送节点向接受节点传送数据（最常用）
远程帧：用于接收节点向某个发送节点请求数据
错误帧：用于当某节点检测出错误时向其他节点通知错误帧
过载帧：用于接收节点向发送节点通知自身接收能力的帧
帧间隔：将数据帧或远程帧与前面的帧分离的帧
## 1.2数据帧格式解析
数据帧组成：
帧起始|仲裁段|控制段|数据段|CRC段|ACK段|帧结束
---|:--:|:--:|:--:|:--:|:--:|---:

### 一、帧起始
帧起始，SOF，由1个显性位组成
***在总线空闲的时候***，发送节点发出帧起始，其他接收节点从这个帧起始位进行<font color=#FF0000>同步。</font>
### 二、仲裁段
标准格式：
ID[0: 10]|RTR
---|:--:|
扩展格式：
ID[0: 10]| SRR| IDE|ID[11: 28]| RTR|
---|:--:|:--:|:--:|:--:|

- 扩展帧：29位ID，前11ID位置与标准帧ID编码位置相同
- SRR：代替远程帧请求位，占1bit,为显性
- IDE：识别符扩展位，占1bit
     标准帧中该位位于<font color=#FF0000>控制段</font>，为显性
     扩展帧中该位位于<font color=#FF0000>仲裁段</font>，为隐性
- RTR：远程帧发送标识位，占1bit，为显性

#### 掌握仲裁机制
ID越小越优先

### 三、控制段
标准格式：
IDE| r0 | DLC|
---|:--:|:--:|
扩展格式：
r1 | r0 | DLC|
---|:--:|:--:|
- IDE：识别符扩展位，占1bit
     标准帧中该位位于<font color=#FF0000>控制段</font>，为显性
     扩展帧中该位位于<font color=#FF0000>仲裁段</font>，为隐性
- DLC：数据段的长度码，占4bit，BCD编码，范围**0~8**
  ***PS：接收方对DLC=9~15的情况并不视为错误***
- r0、r1：保留位0和1，各占1bit,总是用显性电平填充
### 四、数据段
***Data: Byte0 ~ Byte7,八位字节***
**传输时首先发送MSB（最高位），大端模式（Motoroal）**
在报文解析软件（如PE5）中可以自行设置解析报文格式为Motrola/Intel

一般在发送报文的时候会设置报文的发送模式，Motorola（大端模式，低位高地址，高位低地址）或者Intel（小端模式，高位高地址，低位低地址）
个人觉得用Intel好一些比较容易理解，报文数据解析起来也方便。
**这里说一下我使用Motrola发报文遇到的问题以及为什么使用Intel模式好**
这里我在使用Motrola发送数据再用PE5解析报文的时候发现，如果我发的数据是先发了4个bit随后再发1个byte的数据。再用PE5解析的时候Byte0那个内存0——3bit位没有数据（因为Motrolas数据从高地址开始），随后那个1Byte的数据从Byte1开始存储数据。等于说Byte0那个内存0——3bit就浪费了。用Intel模式就不会出现这个问题。
### 五、CRC段
这个段我们不需要去关注太多，知道这是判断数据帧是否有效就行。就是发送的数据和接收节点收到的报文是否正确。
简单说一下此段的帧格式：
CRC值[0: 14]|CRC界定符|
---         |    :--:|
### 六、ACK段
发送节点根据此段判断报文是否发送成功。
结构：
ACK应答位|ACK界定符（1个隐性电平）|
---         |    :--:|
ACK应答位：
发送节点：发送隐性电平
接收正确的节点：发送显性电平
总线显与结果：显性电平
### 七、帧结束
由7个连续的隐性位组成
### 八、帧间隔ITM
帧间隔ITM：
3个连续的隐性位组成
总线空闲：
11个连续隐性位，帧间隔ITM在末尾的连续3个隐性位